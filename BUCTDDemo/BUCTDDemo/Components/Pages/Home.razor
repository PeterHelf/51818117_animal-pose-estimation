@page "/"
@rendermode InteractiveServer
@using Microsoft.AspNetCore.Components.Forms
@using BUCTDDemo.Services
@using Microsoft.ML.OnnxRuntime
@using Microsoft.ML.OnnxRuntime.Tensors
@using SixLabors.ImageSharp
@using SixLabors.ImageSharp.PixelFormats
@using SixLabors.ImageSharp.Processing
@using System.Linq
@inject OnnxModelService OnnxService

<h3>Upload an image of an animal to estimate the pose</h3>

<InputFile OnChange="OnInputFileChange" accept="image/*" />

@if (!string.IsNullOrEmpty(PreviewImageDataUrl))
{
    <div style="margin-top:1rem; display:flex; gap:1rem; align-items:center; width:80%; flex-wrap:wrap;">
        <div style="position:relative; flex:1 1 0; min-width:0;">
            <img src="@PreviewImageDataUrl" alt="Preview" style="width:100%; height:auto; display:block; border:1px solid #ccc;" />

            @if (IsLoading)
            {
                <div style="position:absolute; inset:0; display:flex; align-items:center; justify-content:center; background:rgba(0,0,0,0.4); z-index:10;">
                    <div class="text-center" style="color:white;">
                        <div class="spinner-border" role="status" style="width:3rem;height:3rem;">
                            <span class="visually-hidden">Loading...</span>
                        </div>
                        <div style="margin-top:0.5rem;">Calculating keypoints…</div>
                    </div>
                </div>
            }

            <svg viewBox="0 0 @DisplayWidthPx @DisplayHeightPx" aria-hidden="true" style="position:absolute; left:0; top:0; width:100%; height:100%; pointer-events:none;">
                @* Draw skeleton lines and keypoints per individual*@
                @foreach (var individual in DrawKeypoints.GroupBy(k => k.IndividualId))
                {
                    var color = individualColors[individual.Key % individualColors.Length];

                    @* Draw skeleton lines for this individual *@
                    foreach (var edge in SkeletonEdges)
                    {
                        var a = edge.Item1;
                        var b = edge.Item2;
                        var ka = individual.FirstOrDefault(k => k.KeypointNr == a);
                        var kb = individual.FirstOrDefault(k => k.KeypointNr == b);
                        if (ka is not null && kb is not null)
                        {
                            <line x1="@ka.X" y1="@ka.Y" x2="@kb.X" y2="@kb.Y"
                                  stroke="@color" stroke-width="2" stroke-linecap="round" opacity="0.9" />
                        }
                    }

                    @* Draw keypoint markers and labels for this individual *@
                    foreach (var kp in individual)
                    {
                        <circle cx="@kp.X" cy="@kp.Y" r="3" fill="@color" stroke="white" stroke-width="1" opacity="0.95" />
                        <text>
                            <text x="@(kp.X - 2)" y="@(kp.Y + 2)" font-size="5" fill="white" stroke="black" stroke-width="0.5">
                                @kp.KeypointNr
                            </text>
                        </text>
                    }
                }
            </svg>
        </div>

        <div style="flex:0 0 320px; max-width:33%; min-width:220px; align-self:center;">
            <table class="table table-sm mb-0">
                <thead>
                    <tr>
                        <th style="width:8%;">#</th>
                        <th>Keypoint</th>
                        <th style="width:8%;">#</th>
                        <th>Keypoint</th>
                    </tr>
                </thead>
                <tbody>
                    <tr><td>1</td><td>Left Eye</td><td>10</td><td>Right Elbow</td></tr>
                    <tr><td>2</td><td>Right Eye</td><td>11</td><td>Right Front Paw</td></tr>
                    <tr><td>3</td><td>Nose</td><td>12</td><td>Left Hip</td></tr>
                    <tr><td>4</td><td>Neck</td><td>13</td><td>Left Knee</td></tr>
                    <tr><td>5</td><td>Root of Tail</td><td>14</td><td>Left Back Paw</td></tr>
                    <tr><td>6</td><td>Left Shoulder</td><td>15</td><td>Right Hip</td></tr>
                    <tr><td>7</td><td>Left Elbow</td><td>16</td><td>Right Knee</td></tr>
                    <tr><td>8</td><td>Left Front Paw</td><td>17</td><td>Right Back Paw</td></tr>
                    <tr><td>9</td><td>Right Shoulder</td><td></td><td></td></tr>
                </tbody>
            </table>
        </div>
    </div>
}

@if (!string.IsNullOrEmpty(InferenceSummary))
{
    <div style="margin-top:1rem;">
        <strong>Inference:</strong> @InferenceSummary
    </div>
}

@code {
    private string? PreviewImageDataUrl;
    private byte[,,]? Image;
    private string? InferenceSummary;

    // keypoints to draw (in image pixel coordinates)
    private List<Keypoint> DrawKeypoints = new();

    private static readonly (int, int)[] SkeletonEdges = new[]
    {
        (1, 2),  // Left Eye -> Right Eye
        (1, 3),  // Left Eye -> Nose
        (2, 3),  // Right Eye -> Nose
        (3, 4),  // Nose -> Neck
        (4, 6),  // Neck -> Left Shoulder
        (4, 9),  // Neck -> Right Shoulder
        (6, 7),  // Left Shoulder -> Left Elbow
        (7, 8),  // Left Elbow -> Left Front Paw
        (9, 10), // Right Shoulder -> Right Elbow
        (10, 11),// Right Elbow -> Right Front Paw
        (4, 5),  // Neck -> Root of Tail
        (5, 12), // Root of Tail -> Left Hip
        (5, 15), // Root of Tail -> Right Hip
        (12, 13),// Left Hip -> Left Knee
        (13, 14),// Left Knee -> Left Back Paw
        (15, 16),// Right Hip -> Right Knee
        (16, 17) // Right Knee -> Right Back Paw
    };

    private const long MaxFileSize = 10 * 1024 * 1024; // 10 MB
    private const int TargetSize = 256;

    private int DisplayWidthPx = TargetSize;
    private int DisplayHeightPx = TargetSize;

    private bool IsLoading = false;

    private record Keypoint(int X, int Y, float Prob, int KeypointNr, int IndividualId);

    // color palette for different detected individuals
    private readonly string[] individualColors = new[]
    {
        "#FF3B30", // red
        "#34C759", // green
        "#007AFF", // blue
        "#FF9500", // orange
        "#AF52DE", // purple
        "#FF2D55"  // pink
    };

    private async Task OnInputFileChange(InputFileChangeEventArgs e)
    {
        var file = e.File;
        InferenceSummary = null;
        DrawKeypoints.Clear();

        if (file is null)
        {
            PreviewImageDataUrl = null;
            Image = null;
            return;
        }

        IsLoading = true;
        StateHasChanged();

        try
        {
            await ProcessFileAsync(file);
        }
        finally
        {
            IsLoading = false;
            StateHasChanged();
        }
    }

    private async Task ProcessFileAsync(IBrowserFile file)
    {
        // Read file bytes
        await using var ms = new MemoryStream();
        await file.OpenReadStream(MaxFileSize).CopyToAsync(ms);
        var bytes = ms.ToArray();

        // Load and resize image
        await using var imageStream = new MemoryStream(bytes);
        using var image = await SixLabors.ImageSharp.Image.LoadAsync<Rgba32>(imageStream);

        image.Mutate(ctx => ctx.Resize(new ResizeOptions
        {
            Size = new Size(TargetSize, TargetSize),
            Mode = ResizeMode.Pad,
            PadColor = Color.Black
        }));

        // Save preview
        PreviewImageDataUrl = await CreatePreviewDataUrlAsync(image);
        StateHasChanged();

        // prepare raw image array and metadata
        Image = CreateImageArrayFromImage(image);

        if (Image is null)
        {
            InferenceSummary = "Image could not be read.";
            return;
        }

        // Build image tensor [1,3,H,W]
        var imageTensor = BuildImageTensor(Image, TargetSize, TargetSize);

        var kpCount = 17;

        // Build conditioning tensor
        var condTensor = BuildCondTensor(imageTensor, TargetSize, TargetSize, kpCount);

        // Run model per detected individual
        await RunModelForIndividualsAsync(image, condTensor, TargetSize, TargetSize, kpCount);
    }

    private async Task<string> CreatePreviewDataUrlAsync(Image<Rgba32> image)
    {
        await using var outMs = new MemoryStream();
        await image.SaveAsPngAsync(outMs);
        return $"data:image/png;base64,{Convert.ToBase64String(outMs.ToArray())}";
    }

    // return a byte[channels, H, W] from Image
    private byte[,,] CreateImageArrayFromImage(Image<Rgba32> image)
    {
        var w = image.Width;
        var h = image.Height;
        const int channels = 4;
        var arr = new byte[channels, h, w];

        for (var y = 0; y < h; y++)
        {
            for (var x = 0; x < w; x++)
            {
                var px = image[x, y];
                arr[0, y, x] = px.R;
                arr[1, y, x] = px.G;
                arr[2, y, x] = px.B;
                arr[3, y, x] = px.A;
            }
        }

        return arr;
    }

    private DenseTensor<float> BuildImageTensor(byte[,,] img, int imageWidth, int imageHeight)
    {
        var tensorShape = new[] { 1, 3, imageHeight, imageWidth };
        var imageTensor = new DenseTensor<float>(tensorShape);

        // ImageNet mean/std (RGB)
        const float meanR = 0.485f, meanG = 0.456f, meanB = 0.406f;
        const float stdR = 0.229f, stdG = 0.224f, stdB = 0.225f;

        for (var y = 0; y < imageHeight; y++)
        {
            for (var x = 0; x < imageWidth; x++)
            {
                var r = img[0, y, x] / 255f;
                var g = img[1, y, x] / 255f;
                var b = img[2, y, x] / 255f;

                imageTensor[0, 0, y, x] = (r - meanR) / stdR; // R
                imageTensor[0, 1, y, x] = (g - meanG) / stdG; // G
                imageTensor[0, 2, y, x] = (b - meanB) / stdB; // B
            }
        }

        return imageTensor;
    }

    private DenseTensor<float> BuildCondTensor(DenseTensor<float> imageTensor, int imageWidth, int imageHeight, int kpCount)
    {
        if (!OnnxService.HrnetAvailable)
        {
            return CreateRandomCondTensor(imageWidth, imageHeight, kpCount);
        }

        try
        {
            var hrInputNames = OnnxService.HrnetInputNames;
            var hrImageInputName = hrInputNames?.FirstOrDefault() ?? OnnxService.InputNames.First();
            var hrImageInput = NamedOnnxValue.CreateFromTensor(hrImageInputName, imageTensor);

            using var hrResults = OnnxService.RunHrnet(new[] { hrImageInput });

            var hrTensor = hrResults.Select(r => r.Value).OfType<Tensor<float>>().FirstOrDefault();
            if (hrTensor == null)
            {
                return CreateRandomCondTensor(imageWidth, imageHeight, kpCount);
            }

            var dims = hrTensor.Dimensions.ToArray();
            var repeats = dims[1];
            var condList = new List<int>();

            // filter low-confidence detections
            for (var r = 0; r < repeats; r++)
            {
                var conf = 0.0;
                for (var i = 0; i < kpCount; i++)
                {
                    conf += hrTensor[0, r, i, 2];
                }

                if (conf > 2)
                {
                    condList.Add(r);
                }
            }

            if (condList.Count == 0)
            {
                return CreateRandomCondTensor(imageWidth, imageHeight, kpCount);
            }

            var condTensor = new DenseTensor<float>(new[] { 1, condList.Count, kpCount, 3 });
            for (int i = 0; i < condList.Count; i++)
            {
                var index = condList[i];
                for (int k = 0; k < kpCount; k++)
                {
                    condTensor[0, i, k, 0] = MathF.Max(0, MathF.Min(TargetSize, hrTensor[0, index, k, 0]));
                    condTensor[0, i, k, 1] = MathF.Max(0, MathF.Min(TargetSize, hrTensor[0, index, k, 1]));
                    condTensor[0, i, k, 2] = hrTensor[0, index, k, 2];
                }
            }

            return condTensor;
        }
        catch
        {
            return CreateRandomCondTensor(imageWidth, imageHeight, kpCount);
        }
    }

    private async Task RunModelForIndividualsAsync(Image<Rgba32> image, DenseTensor<float> condTensor, int W, int H, int kpCount)
    {
        try
        {
            var inputNames = OnnxService.InputNames;
            if (inputNames is null || !inputNames.Any())
            {
                InferenceSummary = "Model input names not available.";
                return;
            }

            var imageInputName = inputNames.First();
            var condInputName = inputNames.ElementAt(1);

            var condDimensions = condTensor.Dimensions;
            var individuals = condDimensions[1];
            var condKpCount = condDimensions[2];
            var condChannels = condDimensions[3];

            for (int i = 0; i < individuals; i++)
            {
                // copy per-individual
                var slicedCondTensor = CopyCondSlice(condTensor, i, condKpCount, condChannels);

                // compute bbox
                var (left, top, right, bottom) = ComputeBoundingBoxFromCond(slicedCondTensor, W, H);

                var cropW = Math.Max(1, right - left);
                var cropH = Math.Max(1, bottom - top);

                // crop & resize to TargetSize
                using var individualCrop = image.Clone(ctx => ctx.Crop(new Rectangle(left, top, cropW, cropH)));
                individualCrop.Mutate(ctx => ctx.Resize(new ResizeOptions
                {
                    Size = new Size(TargetSize, TargetSize),
                    Mode = ResizeMode.Stretch
                }));

                var cropBytes = CreateImageArrayFromImage(individualCrop);
                var cropTensor = BuildImageTensor(cropBytes, individualCrop.Width, individualCrop.Height);

                var adjustedCond = AdjustCondCoordinates(slicedCondTensor, left, top, cropW, cropH, condKpCount);

                var imageInputCrop = NamedOnnxValue.CreateFromTensor(imageInputName, cropTensor);
                var condInput = NamedOnnxValue.CreateFromTensor(condInputName, adjustedCond);

                using var results = OnnxService.Run(new[] { imageInputCrop, condInput });

                foreach (var result in results)
                {
                    if (result.Value is Tensor<float> t)
                    {
                        for (int j = 0; j < kpCount; j++)
                        {
                            float outX = t[0, 0, j, 0];
                            float outY = t[0, 0, j, 1];
                            float outP = t[0, 0, j, 2];

                            var origOutX = (outX / TargetSize) * cropW + left;
                            var origOutY = (outY / TargetSize) * cropH + top;

                            AddKeypointIfVisible(origOutX, origOutY, outP, W, H, j + 1, i);
                        }
                    }
                }
            }

            InferenceSummary = $"Ran model on {W}x{H} image. Drew {DrawKeypoints.Count} keypoints across {DrawKeypoints.Select(k => k.IndividualId).Distinct().Count()} individuals.";
        }
        catch (Exception ex)
        {
            InferenceSummary = $"Inference failed: {ex.Message}";
        }
    }

    private DenseTensor<float> CopyCondSlice(DenseTensor<float> condTensor, int sliceIndex, int condKpCount, int condChannels)
    {
        var slicedCondTensor = new DenseTensor<float>(new[] { 1, 1, condKpCount, condChannels });
        for (int k = 0; k < condKpCount; k++)
        {
            for (int c = 0; c < condChannels; c++)
            {
                slicedCondTensor[0, 0, k, c] = condTensor[0, sliceIndex, k, c];
            }
        }

        return slicedCondTensor;
    }

    private (int left, int top, int right, int bottom) ComputeBoundingBoxFromCond(DenseTensor<float> slicedCondTensor, int imageWidth, int imageHeight)
    {
        int condKpCount = slicedCondTensor.Dimensions[2];
        float minX = float.MaxValue, minY = float.MaxValue, maxX = float.MinValue, maxY = float.MinValue;

        for (int k = 0; k < condKpCount; k++)
        {
            var px = slicedCondTensor[0, 0, k, 0];
            var py = slicedCondTensor[0, 0, k, 1];

            if (px < minX) minX = px;
            if (py < minY) minY = py;
            if (px > maxX) maxX = px;
            if (py > maxY) maxY = py;
        }

        var bboxW = MathF.Max(1, maxX - minX);
        var bboxH = MathF.Max(1, maxY - minY);
        var pad = MathF.Max(bboxW, bboxH) * 0.2f;

        var leftF = MathF.Max(0, minX - pad);
        var topF = MathF.Max(0, minY - pad);
        var rightF = MathF.Min(imageWidth, maxX + pad);
        var bottomF = MathF.Min(imageHeight, maxY + pad);

        var left = (int)MathF.Floor(leftF);
        var top = (int)MathF.Floor(topF);
        var right = (int)MathF.Ceiling(rightF);
        var bottom = (int)MathF.Ceiling(bottomF);

        return (left, top, right, bottom);
    }

    private DenseTensor<float> AdjustCondCoordinates(DenseTensor<float> slicedCondTensor, int left, int top, int cropW, int cropH, int condKpCount)
    {
        var adjustedCond = new DenseTensor<float>(new[] { 1, 1, condKpCount, 3 });
        float scaleX = (float)TargetSize / cropW;
        float scaleY = (float)TargetSize / cropH;

        for (int k = 0; k < condKpCount; k++)
        {
            var origX = slicedCondTensor[0, 0, k, 0];
            var origY = slicedCondTensor[0, 0, k, 1];
            var origP = slicedCondTensor[0, 0, k, 2];

            var localX = (origX - left) * scaleX;
            var localY = (origY - top) * scaleY;

            localX = MathF.Max(0, MathF.Min(TargetSize, localX));
            localY = MathF.Max(0, MathF.Min(TargetSize, localY));

            adjustedCond[0, 0, k, 0] = localX;
            adjustedCond[0, 0, k, 1] = localY;
            adjustedCond[0, 0, k, 2] = origP;
        }

        return adjustedCond;
    }

    // Adds keypoint to DrawKeypoints if probability > 0.2.
    private void AddKeypointIfVisible(float xPix, float yPix, float prob, int imageWidth, int imageHeight, int keypointNr, int individualId)
    {
        if (prob <= 0.2f) return;

        // Clamp to image bounds
        xPix = MathF.Max(0, MathF.Min(imageWidth, xPix));
        yPix = MathF.Max(0, MathF.Min(imageHeight, yPix));

        DrawKeypoints.Add(new Keypoint(((int)xPix), ((int)yPix), prob, keypointNr, individualId));
    }

    private static DenseTensor<float> CreateRandomCondTensor(int imageWidth, int imageHeight, int kpCount)
    {
        var condTensor = new DenseTensor<float>(new[] { 1, 1, kpCount, 3 });

        var rnd = Random.Shared;
        for (var i = 0; i < kpCount; i++)
        {
            var xNorm = (float)rnd.NextDouble() * imageWidth;
            var yNorm = (float)rnd.NextDouble() * imageHeight;
            var prob = 1f;

            condTensor[0, 0, i, 0] = xNorm;
            condTensor[0, 0, i, 1] = yNorm;
            condTensor[0, 0, i, 2] = prob;
        }

        return condTensor;
    }
}