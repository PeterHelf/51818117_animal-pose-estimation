@page "/"
@rendermode InteractiveServer
@using Microsoft.AspNetCore.Components.Forms
@using BUCTDDemo.Services
@using Microsoft.ML.OnnxRuntime
@using Microsoft.ML.OnnxRuntime.Tensors
@using SixLabors.ImageSharp
@using SixLabors.ImageSharp.PixelFormats
@using SixLabors.ImageSharp.Processing
@inject OnnxModelService OnnxService

<h3>Upload an image of an animal to estimate the pose</h3>

<InputFile OnChange="OnInputFileChange" accept="image/*" />

@if (!string.IsNullOrEmpty(PreviewImageDataUrl))
{
    <div style="margin-top:1rem; display:flex; gap:1rem; align-items:center; width:80%; flex-wrap:wrap;">
        <div style="position:relative; flex:1 1 0; min-width:0;">
            <img src="@PreviewImageDataUrl" alt="Preview" style="width:100%; height:auto; display:block; border:1px solid #ccc;" />

            @if (IsLoading)
            {
                <div style="position:absolute; inset:0; display:flex; align-items:center; justify-content:center; background:rgba(0,0,0,0.4); z-index:10;">
                    <div class="text-center" style="color:white;">
                        <div class="spinner-border" role="status" style="width:3rem;height:3rem;">
                            <span class="visually-hidden">Loading...</span>
                        </div>
                        <div style="margin-top:0.5rem;">Calculating keypoints…</div>
                    </div>
                </div>
            }

            <svg viewBox="0 0 @DisplayWidthPx @DisplayHeightPx" aria-hidden="true" style="position:absolute; left:0; top:0; width:100%; height:100%; pointer-events:none;">
                @* Draw skeleton lines first so keypoint circles render on top *@
                @foreach (var edge in SkeletonEdges)
                {
                    var a = edge.Item1;
                    var b = edge.Item2;
                    var ka = DrawKeypoints.FirstOrDefault(k => k.KeypointNr == a);
                    var kb = DrawKeypoints.FirstOrDefault(k => k.KeypointNr == b);
                    if (ka is not null && kb is not null)
                    {
                        <line x1="@ka.X" y1="@ka.Y" x2="@kb.X" y2="@kb.Y"
                              stroke="lime" stroke-width="2" stroke-linecap="round" opacity="0.9" />
                    }
                }

                @* Draw keypoint markers and labels *@
                @foreach (var kp in DrawKeypoints)
                {
                    <circle cx="@kp.X" cy="@kp.Y" r="4" fill="red" stroke="white" stroke-width="1" opacity="0.9" />
                    <text>
                        <text x="@(kp.X - 2)" y="@(kp.Y + 2)" font-size="5" fill="white" stroke="black" stroke-width="0.5">
                            @kp.KeypointNr
                        </text>
                    </text>
                }
            </svg>
        </div>

        <div style="flex:0 0 320px; max-width:33%; min-width:220px; align-self:center;">
            <table class="table table-sm mb-0">
                <thead>
                    <tr>
                        <th style="width:8%;">#</th>
                        <th>Keypoint</th>
                        <th style="width:8%;">#</th>
                        <th>Keypoint</th>
                    </tr>
                </thead>
                <tbody>
                    <tr><td>1</td><td>Left Eye</td><td>10</td><td>Right Elbow</td></tr>
                    <tr><td>2</td><td>Right Eye</td><td>11</td><td>Right Front Paw</td></tr>
                    <tr><td>3</td><td>Nose</td><td>12</td><td>Left Hip</td></tr>
                    <tr><td>4</td><td>Neck</td><td>13</td><td>Left Knee</td></tr>
                    <tr><td>5</td><td>Root of Tail</td><td>14</td><td>Left Back Paw</td></tr>
                    <tr><td>6</td><td>Left Shoulder</td><td>15</td><td>Right Hip</td></tr>
                    <tr><td>7</td><td>Left Elbow</td><td>16</td><td>Right Knee</td></tr>
                    <tr><td>8</td><td>Left Front Paw</td><td>17</td><td>Right Back Paw</td></tr>
                    <tr><td>9</td><td>Right Shoulder</td><td></td><td></td></tr>
                </tbody>
            </table>
        </div>
    </div>
}

@if (!string.IsNullOrEmpty(InferenceSummary))
{
    <div style="margin-top:1rem;">
        <strong>Inference:</strong> @InferenceSummary
    </div>
}

@code {
    private string? PreviewImageDataUrl;
    private byte[,,]? Image;
    private int Width;
    private int Height;
    private int Channels;
    private string? InferenceSummary;

    // keypoints to draw (in image pixel coordinates)
    private List<Keypoint> DrawKeypoints = new();

    private static readonly (int, int)[] SkeletonEdges = new[]
    {
        (1, 2),  // Left Eye -> Right Eye
        (1, 3),  // Left Eye -> Nose
        (2, 3),  // Right Eye -> Nose
        (3, 4),  // Nose -> Neck
        (4, 6),  // Neck -> Left Shoulder
        (4, 9),  // Neck -> Right Shoulder
        (6, 7),  // Left Shoulder -> Left Elbow
        (7, 8),  // Left Elbow -> Left Front Paw
        (9, 10), // Right Shoulder -> Right Elbow
        (10, 11),// Right Elbow -> Right Front Paw
        (4, 5),  // Neck -> Root of Tail
        (5, 12), // Root of Tail -> Left Hip
        (5, 15), // Root of Tail -> Right Hip
        (12, 13),// Left Hip -> Left Knee
        (13, 14),// Left Knee -> Left Back Paw
        (15, 16),// Right Hip -> Right Knee
        (16, 17) // Right Knee -> Right Back Paw
    };

    private const long MaxFileSize = 10 * 1024 * 1024; // 10 MB
    private const int TargetSize = 256;

    private int DisplayWidthPx = TargetSize;
    private int DisplayHeightPx = TargetSize;

    private bool IsLoading = false;

    private record Keypoint(int X, int Y, float Prob, int KeypointNr);

    private async Task OnInputFileChange(InputFileChangeEventArgs e)
    {
        var file = e.File;
        InferenceSummary = null;
        DrawKeypoints.Clear();

        if (file is null)
        {
            PreviewImageDataUrl = null;
            Image = null;
            Width = Height = Channels = 0;
            return;
        }

        // Read file bytes
        await using var ms = new MemoryStream();
        await file.OpenReadStream(MaxFileSize).CopyToAsync(ms);
        var bytes = ms.ToArray();

        // Load with ImageSharp, resize to 256x256 (pad to preserve aspect ratio), then create a PNG preview
        await using var imageStream = new MemoryStream(bytes);
        using var image = await SixLabors.ImageSharp.Image.LoadAsync<Rgba32>(imageStream);

        image.Mutate(ctx => ctx.Resize(new ResizeOptions
        {
            Size = new Size(TargetSize, TargetSize),
            Mode = ResizeMode.Pad,
            PadColor = Color.Black
        }));

        // Save resized image to preview data URL
        await using var outMs = new MemoryStream();
        await image.SaveAsPngAsync(outMs);
        PreviewImageDataUrl = $"data:image/png;base64,{Convert.ToBase64String(outMs.ToArray())}";

        // show loading indicator while the model runs
        IsLoading = true;
        StateHasChanged();

        var resizedWidth = image.Width;
        var resizedHeight = image.Height;
        const int channels = 4; // R,G,B,A
        var arr = new byte[channels, resizedHeight, resizedWidth];

        for (var y = 0; y < resizedHeight; y++)
        {
            for (var x = 0; x < resizedWidth; x++)
            {
                var px = image[x, y];
                arr[0, y, x] = px.R;
                arr[1, y, x] = px.G;
                arr[2, y, x] = px.B;
                arr[3, y, x] = px.A;
            }
        }

        Image = arr;
        Height = resizedHeight;
        Width = resizedWidth;
        Channels = channels;

        DisplayWidthPx = Width;
        DisplayHeightPx = Height;

        if (Image is null || Channels < 3)
        {
            InferenceSummary = "Image could not be read or has less than 3 channels.";
            return;
        }

        var H = Height;
        var W = Width;
        var tensorShape = new[] { 1, 3, H, W };
        var imageTensor = new DenseTensor<float>(tensorShape);

        // ImageNet mean/std (RGB)
        const float meanR = 0.485f, meanG = 0.456f, meanB = 0.406f;
        const float stdR = 0.229f, stdG = 0.224f, stdB = 0.225f;

        // Build image tensor [1,3,H,W] normalized to [0,1] and then normalized by ImageNet mean/std.
        for (var y = 0; y < H; y++)
        {
            for (var x = 0; x < W; x++)
            {
                var r = Image[0, y, x] / 255f;
                var g = Image[1, y, x] / 255f;
                var b = Image[2, y, x] / 255f;

                // Apply ImageNet normalization: (value - mean) / std
                imageTensor[0, 0, y, x] = (r - meanR) / stdR; // R
                imageTensor[0, 1, y, x] = (g - meanG) / stdG; // G
                imageTensor[0, 2, y, x] = (b - meanB) / stdB; // B
            }
        }

        var kpCount = 17;

        DenseTensor<float> condTensor;

        if (OnnxService.HrnetAvailable)
        {
            try
            {
                var hrInputNames = OnnxService.HrnetInputNames;
                var hrImageInputName = hrInputNames?.FirstOrDefault() ?? OnnxService.InputNames.First();

                var hrImageInput = NamedOnnxValue.CreateFromTensor(hrImageInputName, imageTensor);

                using var hrResults = OnnxService.RunHrnet(new[] { hrImageInput });

                // Find first tensor<float> output
                var hrTensor = hrResults.Select(r => r.Value).OfType<Tensor<float>>().FirstOrDefault();

                if (hrTensor != null)
                {
                    var dims = hrTensor.Dimensions.ToArray();

                    var repeats = dims[1];
                    condTensor = new DenseTensor<float>(new[] { 1, 1, kpCount, 3 });

                    var highest_conf = 0.0;
                    var highest_conf_index = 0;

                    for (var r = 0; r < repeats; r++)
                    {
                        var conf = 0.0;
                        for (var i = 0; i < kpCount; i++)
                        {
                            conf += hrTensor[0, r, i, 2];
                        }

                        if (conf > highest_conf)
                        {
                            highest_conf_index = r;
                            highest_conf = conf;
                        }
                    }

                    for (var i = 0; i < kpCount; i++)
                    {
                        condTensor[0, 0, i, 0] = MathF.Max(0, MathF.Min(TargetSize, hrTensor[0, highest_conf_index, i, 0]));
                        condTensor[0, 0, i, 1] = MathF.Max(0, MathF.Min(TargetSize, hrTensor[0, highest_conf_index, i, 1]));
                        condTensor[0, 0, i, 2] = hrTensor[0, highest_conf_index, i, 2];
                    }
                }
                else
                {
                    // HRNet produced no float tensor output - fallback to random condition
                    condTensor = new DenseTensor<float>(new[] { 1, 1, kpCount, 3 });
                    FillCondTensorRandom(condTensor, W, H, kpCount);
                }
            }
            catch
            {
                // HRNet run failed - fallback to random condition
                condTensor = new DenseTensor<float>(new[] { 1, 1, kpCount, 3 });
                FillCondTensorRandom(condTensor, W, H, kpCount);
            }
        }
        else
        {
            // HRNet not available - fallback random
            condTensor = new DenseTensor<float>(new[] { 1, 1, kpCount, 3 });
            FillCondTensorRandom(condTensor, W, H, kpCount);
        }

        try
        {
            // Choose input names from the (primary) model
            var inputNames = OnnxService.InputNames;
            if (inputNames is null || !inputNames.Any())
            {
                InferenceSummary = "Model input names not available.";
                return;
            }

            var imageInputName = inputNames.First();
            var condInputName = inputNames.ElementAt(1);

            var imageInput = NamedOnnxValue.CreateFromTensor(imageInputName, imageTensor);
            var condInput = NamedOnnxValue.CreateFromTensor(condInputName, condTensor);
            using var results = OnnxService.Run(new[] { imageInput, condInput });

            foreach (var result in results)
            {
                if (result.Value is Tensor<float> t)
                {
                    for (int i = 0; i < kpCount; i++)
                    {
                        float x = t[0, 0, i, 0];
                        float y = t[0, 0, i, 1];
                        float p = t[0, 0, i, 2];

                        AddKeypointIfVisible(x, y, p, W, H, i + 1);
                    }
                }
            }

            var outNames = results.Select(r => r.Name).ToArray();
            InferenceSummary = $"Ran model on {W}x{H} image. Drew {DrawKeypoints.Count} keypoints.";
        }
        catch (Exception ex)
        {
            InferenceSummary = $"Inference failed: {ex.Message}";
        }
        finally
        {
            IsLoading = false;
            StateHasChanged();
        }
    }

    // Adds keypoint to DrawKeypoints if probability > 0.2.
    // Handles both normalized [0,1] and absolute pixel coordinates.
    private void AddKeypointIfVisible(float xPix, float yPix, float prob, int imageWidth, int imageHeight, int keypointNr)
    {
        if (prob <= 0.2f) return;

        // Clamp to image bounds
        xPix = MathF.Max(0, MathF.Min(imageWidth, xPix));
        yPix = MathF.Max(0, MathF.Min(imageHeight, yPix));

        DrawKeypoints.Add(new Keypoint(((int)xPix), ((int)yPix), prob, keypointNr));
    }

    private static void FillCondTensorRandom(DenseTensor<float> condTensor, int imageWidth, int imageHeight, int kpCount)
    {
        var rnd = Random.Shared;
        for (var i = 0; i < kpCount; i++)
        {
            var xNorm = (float)rnd.NextDouble() * imageWidth;
            var yNorm = (float)rnd.NextDouble() * imageHeight;
            var prob = 1f;

            condTensor[0, 0, i, 0] = xNorm;
            condTensor[0, 0, i, 1] = yNorm;
            condTensor[0, 0, i, 2] = prob;
        }
    }
}